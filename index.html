<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Voxel Builder - Omni Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap');

        :root {
            /* Default to Dark Mode variables */
            --bg-color: #1a1a2e;
            --ui-bg: rgba(20, 20, 35, 0.85);
            --ui-border: rgba(255,255,255,0.15);
            --text-color: #eee;
            --accent: #4fa4b8;
            --slot-bg: #333;
            --btn-shadow: rgba(0,0,0,0.5);
        }

        body.light-mode {
            --bg-color: #87CEEB;
            --ui-bg: rgba(255, 255, 255, 0.65);
            --ui-border: rgba(0,0,0,0.1);
            --text-color: #333;
            --accent: #2c7a8b;
            --slot-bg: #e0e0e0;
            --btn-shadow: rgba(0,0,0,0.2);
        }

        body { margin: 0; overflow: hidden; font-family: 'Fredoka', sans-serif; user-select: none; background: var(--bg-color); transition: background 0.3s; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        /* Top Bar: Theme & Tabs */
        #top-area {
            position: absolute; top: 15px; left: 0; width: 100%;
            display: flex; justify-content: center; align-items: flex-start;
            pointer-events: auto;
        }

        #theme-toggle {
            position: absolute; left: 20px; top: 0;
            background: var(--ui-bg); border: 2px solid var(--ui-border);
            color: var(--text-color); font-size: 20px;
            padding: 8px 12px; border-radius: 50%;
            cursor: pointer; backdrop-filter: blur(5px);
            transition: transform 0.2s;
        }
        #theme-toggle:hover { transform: scale(1.1); }

        /* Dynamic Tabs */
        #tab-container {
            display: flex; gap: 5px;
            background: var(--ui-bg);
            padding: 5px; border-radius: 12px;
            border: 1px solid var(--ui-border);
            backdrop-filter: blur(5px);
            max-width: 80%; overflow-x: auto;
        }

        .world-tab {
            padding: 6px 15px; border-radius: 8px;
            background: transparent; color: var(--text-color);
            border: 1px solid transparent; cursor: pointer;
            font-size: 13px; font-weight: 600;
            display: flex; align-items: center; gap: 8px;
            white-space: nowrap;
        }
        .world-tab.active { background: var(--accent); color: white; box-shadow: 0 2px 5px var(--btn-shadow); }
        .world-tab:hover:not(.active) { background: rgba(128,128,128,0.2); }
        
        .del-tab {
            font-size: 10px; width: 16px; height: 16px;
            background: rgba(0,0,0,0.2); color: white;
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            opacity: 0.6; transition: opacity 0.2s;
        }
        .del-tab:hover { opacity: 1; background: #ff5252; }

        #add-tab-btn {
            padding: 6px 12px; background: rgba(0,255,0,0.1); color: var(--text-color);
            border: 1px dashed var(--ui-border); border-radius: 8px; cursor: pointer;
        }
        #add-tab-btn:hover { background: rgba(0,255,0,0.3); }


        /* Controls */
        #side-controls {
            position: absolute; top: 80px; left: 20px;
            display: flex; flex-direction: column; gap: 10px; pointer-events: auto;
        }
        .btn {
            background: var(--ui-bg); color: var(--text-color);
            border: 1px solid var(--ui-border); padding: 8px 16px;
            border-radius: 8px; cursor: pointer; font-weight: 600; font-family: inherit;
            backdrop-filter: blur(4px); box-shadow: 0 4px 5px var(--btn-shadow);
        }
        .btn:active { transform: translateY(2px); box-shadow: none; }

        /* Instructions - 40% Smaller */
        #instructions {
            position: absolute; top: 20px; right: 20px;
            background: var(--ui-bg); padding: 10px 15px;
            border-radius: 10px; color: var(--text-color);
            font-size: 11px; line-height: 1.5; /* Smaller font */
            backdrop-filter: blur(4px); border: 1px solid var(--ui-border);
            transform: scale(0.9); transform-origin: top right;
        }
        #instructions b { color: var(--accent); }

        /* Hotbar */
        #hotbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: var(--ui-bg); padding: 8px; border-radius: 16px;
            display: flex; gap: 8px; border: 1px solid var(--ui-border);
            pointer-events: auto; box-shadow: 0 5px 20px var(--btn-shadow);
        }
        .slot {
            width: 48px; height: 48px; border-radius: 10px;
            background: var(--slot-bg); border: 2px solid rgba(255,255,255,0.1);
            cursor: pointer; position: relative;
            display: flex; justify-content: center; align-items: center; font-size: 24px;
            transition: transform 0.1s;
        }
        .slot:hover { transform: scale(1.1); border-color: var(--accent); }
        .slot:active { transform: scale(0.95); }

        /* Cursor Icon */
        #carrying-cursor {
            position: fixed; pointer-events: none; z-index: 100;
            display: none; font-size: 24px; filter: drop-shadow(0 0 5px rgba(0,0,0,0.5));
        }

        #fileInput { display: none; }
    </style>
</head>
<body class="dark-mode"> <div id="ui-layer">
        <div id="top-area">
            <button id="theme-toggle" onclick="toggleTheme()">üåó</button>
            <div id="tab-container">
                <button id="add-tab-btn" onclick="createNewWorld()">+</button>
            </div>
        </div>

        <div id="side-controls">
            <button class="btn" onclick="downloadWorld()">üíæ Save .JSON</button>
            <button class="btn" onclick="triggerLoad()">üìÇ Load .JSON</button>
        </div>

        <div id="instructions">
            <b>Left Click Block:</b> Pick Up<br>
            <b>Left Click Empty:</b> Place<br>
            <b>Right Click+Drag:</b> Camera<br>
            <b>R Key:</b> Rotate Beam<br>
            <b>ESC:</b> Cancel
        </div>

        <div id="hotbar">
            <div class="slot" style="background:#58a04c" onclick="startPlacing('grass')">üåø</div>
            <div class="slot" style="background:#7d7d7d" onclick="startPlacing('stone')">ü™®</div>
            <div class="slot" style="background:#8b5a2b" onclick="startPlacing('wood')">ü™µ</div>
            <div class="slot" style="background:#d2a679" onclick="startPlacing('plank')">üìè</div>
            <div class="slot" style="background:#a04c4c" onclick="startPlacing('brick')">üß±</div>
            <div class="slot" style="background:#aed9e0" onclick="startPlacing('glass')">üî≤</div>
            <div class="slot" style="background:#4fa4b8" onclick="startPlacing('waterBlock')">üíß</div>
            <div class="slot" style="background:#fff3bb" onclick="startPlacing('light')">üí°</div>
        </div>

        <div id="carrying-cursor">üì¶</div>
    </div>

    <input type="file" id="fileInput" accept=".json">

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Config ---
        const CONFIG = {
            blockSize: 50,
            islandSize: 50, 
            waterLevel: -30,
            darkSky: 0x1a1a2e,
            lightSky: 0x87CEEB,
            maxWorlds: 10
        };

        let camera, scene, renderer, controls;
        let groundPlane, waterMesh;
        let raycaster, pointer;
        
        // World Management
        let worlds = []; // Array of objects: { id: 1, data: [] }
        let currentWorldId = null;
        let worldCounter = 1;

        // Scene Objects
        let currentInteractables = []; 
        let collisionObjects = []; 
        
        // Interaction State
        let carriedBlock = null; 
        let placementGhost = null; 
        const materials = {};
        
        // Theme State
        let isDarkMode = true;

        init();
        animate();

        // Global functions
        window.startPlacing = startPlacing;
        window.downloadWorld = downloadWorld;
        window.triggerLoad = () => document.getElementById('fileInput').click();
        window.toggleTheme = toggleTheme;
        window.createNewWorld = createNewWorld;
        window.switchWorld = switchWorld;
        window.deleteWorld = deleteWorld;

        document.getElementById('fileInput').addEventListener('change', handleFileLoad, false);

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.darkSky);
            scene.fog = new THREE.Fog(CONFIG.darkSky, 500, 2500);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.set(1200, 1000, 1200);

            // Optimization: No pixelRatio scaling (saves GPU)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFShadowMap; // Faster than PCFSoft
            document.body.appendChild(renderer.domElement);

            setupLighting();
            generateMaterials(); // Pixel art style
            createEnvironment();

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.08;
            controls.maxPolarAngle = Math.PI / 2 - 0.05; 
            controls.minDistance = 100;
            controls.maxDistance = 3000;
            controls.mouseButtons = { LEFT: null, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.ROTATE };

            raycaster = new THREE.Raycaster();
            pointer = new THREE.Vector2();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('pointerdown', onPointerDown);
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('keydown', onKeyDown);

            // Create initial world
            createNewWorld();
        }

        // --- Theme System ---
        function toggleTheme() {
            isDarkMode = !isDarkMode;
            document.body.className = isDarkMode ? 'dark-mode' : 'light-mode';
            
            const color = isDarkMode ? CONFIG.darkSky : CONFIG.lightSky;
            scene.background.setHex(color);
            scene.fog.color.setHex(color);
            
            // Adjust light intensity based on mode
            const sun = scene.getObjectByName('sun');
            if(sun) sun.intensity = isDarkMode ? 1.5 : 2.0;
        }

        // --- Optimized Materials (Pixel Art) ---
        function createPixelTexture(color, transparent=false) {
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color; ctx.fillRect(0,0,size,size);
            
            // Simple noise
            for(let i=0; i<200; i++) {
                ctx.fillStyle = Math.random()>0.5 ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
                const x = Math.floor(Math.random()*size);
                const y = Math.floor(Math.random()*size);
                ctx.fillRect(x,y,4,4);
            }
            
            // Border
            ctx.strokeStyle = "rgba(0,0,0,0.2)"; ctx.lineWidth = 4; ctx.strokeRect(0,0,size,size);

            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter; // Key for pixel look
            return tex;
        }

        function generateMaterials() {
            // Using MeshLambertMaterial for performance (not Physical)
            const mkMat = (c) => new THREE.MeshLambertMaterial({ map: createPixelTexture(c) });
            
            materials['stone'] = mkMat('#7d7d7d');
            materials['wood'] = mkMat('#8b5a2b');
            materials['brick'] = mkMat('#a04c4c');
            materials['plank'] = mkMat('#d2a679');
            
            materials['glass'] = new THREE.MeshLambertMaterial({
                color: 0xaed9e0, transparent: true, opacity: 0.4,
                map: createPixelTexture('#aed9e0')
            });
            
            materials['waterBlock'] = new THREE.MeshLambertMaterial({
                color: 0x4fa4b8, transparent: true, opacity: 0.7,
                map: createPixelTexture('#4fa4b8')
            });

            materials['light'] = new THREE.MeshLambertMaterial({
                color: 0xfff3bb, emissive: 0xffe066, emissiveIntensity: 1,
                map: createPixelTexture('#fff3bb')
            });

            // Grass
            const dirt = createPixelTexture('#5d4037');
            const grass = createPixelTexture('#58a04c');
            materials['grass'] = [
                new THREE.MeshLambertMaterial({map: dirt}), new THREE.MeshLambertMaterial({map: dirt}),
                new THREE.MeshLambertMaterial({map: grass}), new THREE.MeshLambertMaterial({map: dirt}),
                new THREE.MeshLambertMaterial({map: dirt}), new THREE.MeshLambertMaterial({map: dirt})
            ];
            
            // Environment Water
            materials['sea'] = new THREE.MeshLambertMaterial({
                color: 0x4fa4b8, transparent: true, opacity: 0.85
            });
        }

        function setupLighting() {
            const amb = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(amb);
            
            const sun = new THREE.DirectionalLight(0xfff5e1, 1.5);
            sun.name = 'sun';
            sun.position.set(500, 1000, 500);
            sun.castShadow = true;
            sun.shadow.mapSize.set(2048, 2048); // Reduced from 4096
            sun.shadow.camera.far = 3500;
            const d = 1500;
            sun.shadow.camera.left = -d; sun.shadow.camera.right = d;
            sun.shadow.camera.top = d; sun.shadow.camera.bottom = -d;
            scene.add(sun);
        }

        function createEnvironment() {
            // Platform
            const size = CONFIG.blockSize * CONFIG.islandSize;
            const geo = new THREE.BoxGeometry(size, CONFIG.blockSize, size);
            groundPlane = new THREE.Mesh(geo, materials['grass']);
            groundPlane.position.y = -CONFIG.blockSize/2;
            groundPlane.receiveShadow = true;
            scene.add(groundPlane);

            // Water Plane
            const wGeo = new THREE.PlaneGeometry(8000, 8000);
            waterMesh = new THREE.Mesh(wGeo, materials['sea']);
            waterMesh.rotation.x = -Math.PI/2;
            waterMesh.position.y = CONFIG.waterLevel;
            scene.add(waterMesh);

            // Mountains Only
            const mtnMat = new THREE.MeshLambertMaterial({color: 0x5a6e8c});
            for(let i=0; i<30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = size/2 + 600 + Math.random()*1500;
                const h = 800 + Math.random()*1000;
                const r = 600 + Math.random()*600;
                const cone = new THREE.Mesh(new THREE.ConeGeometry(r, h, 5), mtnMat);
                cone.position.set(Math.cos(angle)*dist, h/2 - 100, Math.sin(angle)*dist);
                scene.add(cone);
            }
        }

        // --- Interaction ---
        function startPlacing(type) {
            if(carriedBlock) dropCarried();
            const size = CONFIG.blockSize;
            const geo = (type==='plank') ? new THREE.BoxGeometry(size, size, size*2) : new THREE.BoxGeometry(size, size, size);
            
            carriedBlock = new THREE.Mesh(geo, materials[type]);
            carriedBlock.castShadow = true;
            carriedBlock.receiveShadow = true;
            carriedBlock.userData = { type: type, r: false };
            
            if(type === 'light') {
                carriedBlock.add(new THREE.PointLight(0xffaa00, 500, 300));
            }

            scene.add(carriedBlock);
            placementGhost = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color:0x00ff00, wireframe:true, opacity:0.5, transparent:true}));
            scene.add(placementGhost);
            
            updateCursor(true);
        }

        function onPointerDown(e) {
            if(e.button !== 0 || e.target.closest('#ui-layer button') || e.target.closest('.slot')) return;
            
            updatePointer(e);
            raycaster.setFromCamera(pointer, camera);

            if(carriedBlock) {
                // Place
                const intersects = raycaster.intersectObjects(collisionObjects, false);
                if(intersects.length > 0) {
                    carriedBlock.position.copy(placementGhost.position);
                    currentInteractables.push(carriedBlock);
                    collisionObjects.push(carriedBlock);
                    carriedBlock = null;
                    scene.remove(placementGhost);
                    placementGhost = null;
                    updateCursor(false);
                }
            } else {
                // Pick Up
                const intersects = raycaster.intersectObjects(currentInteractables, false);
                if(intersects.length > 0) {
                    const target = intersects[0].object;
                    carriedBlock = target;
                    currentInteractables = currentInteractables.filter(o => o !== target);
                    collisionObjects = collisionObjects.filter(o => o !== target);
                    
                    placementGhost = new THREE.Mesh(target.geometry, new THREE.MeshBasicMaterial({color:0x00ff00, wireframe:true}));
                    placementGhost.userData.r = target.userData.r;
                    scene.add(placementGhost);
                    updateCursor(true);
                }
            }
        }

        function onPointerMove(e) {
            if(!carriedBlock) return;
            updatePointer(e);
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(collisionObjects, false);
            
            if(intersects.length > 0) {
                const hit = intersects[0];
                const size = CONFIG.blockSize;
                const pos = new THREE.Vector3().copy(hit.point).add(hit.face.normal.multiplyScalar(size/2));
                pos.divideScalar(size).floor().multiplyScalar(size).addScalar(size/2);
                
                placementGhost.position.copy(pos);
                
                // Alignment for beams
                if(carriedBlock.userData.type === 'plank') {
                     const off = size/2;
                     if(!placementGhost.userData.r) { if(Math.round(pos.z/off)%2 !== 0) placementGhost.position.z += off; }
                     else { if(Math.round(pos.x/off)%2 !== 0) placementGhost.position.x += off; }
                }
                carriedBlock.position.set(0, 5000, 0); // Hide carrying block
            }
        }

        function onKeyDown(e) {
            if((e.key === 'r' || e.key === 'R') && carriedBlock && carriedBlock.userData.type === 'plank') {
                const r = !carriedBlock.userData.r;
                carriedBlock.userData.r = r;
                placementGhost.userData.r = r;
                const size = CONFIG.blockSize;
                const g = r ? new THREE.BoxGeometry(size*2, size, size) : new THREE.BoxGeometry(size, size, size*2);
                carriedBlock.geometry.dispose(); carriedBlock.geometry = g;
                placementGhost.geometry.dispose(); placementGhost.geometry = g;
            }
            if(e.key === 'Escape' && carriedBlock) dropCarried();
        }

        function dropCarried() {
            if(carriedBlock) scene.remove(carriedBlock);
            if(placementGhost) scene.remove(placementGhost);
            carriedBlock = null; placementGhost = null;
            updateCursor(false);
        }
        
        function updatePointer(e) { pointer.set((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1); }
        function updateCursor(active) {
            const c = document.getElementById('carrying-cursor');
            c.style.display = active ? 'block' : 'none';
            document.body.style.cursor = active ? 'grabbing' : 'default';
            if(active) {
                const track = (e) => { c.style.left = e.clientX+15+'px'; c.style.top = e.clientY+15+'px'; };
                document.addEventListener('pointermove', track, {once: !active});
            }
        }

        // --- Multi-World Logic ---

        function saveCurrentWorldState() {
            if(currentWorldId === null) return;
            const worldObj = worlds.find(w => w.id === currentWorldId);
            if(worldObj) {
                worldObj.data = currentInteractables.map(b => ({
                    type: b.userData.type, x: b.position.x, y: b.position.y, z: b.position.z, r: b.userData.r
                }));
            }
        }

        function createNewWorld() {
            if(worlds.length >= CONFIG.maxWorlds) return alert("Max 10 worlds allowed!");
            const newWorld = { id: worldCounter++, data: [] };
            worlds.push(newWorld);
            renderTabs();
            switchWorld(newWorld.id);
        }

        function deleteWorld(id, e) {
            e.stopPropagation();
            if(worlds.length <= 1) return alert("Cannot delete the last world.");
            if(!confirm("Delete this world?")) return;
            
            const idx = worlds.findIndex(w => w.id === id);
            worlds.splice(idx, 1);
            
            // If we deleted the active world, switch to the first available
            if(currentWorldId === id) {
                currentInteractables.forEach(o => scene.remove(o)); // Clear visuals
                currentInteractables = [];
                switchWorld(worlds[0].id);
            } else {
                renderTabs();
            }
        }

        function switchWorld(id) {
            if(currentWorldId === id) return;
            saveCurrentWorldState();
            
            // Clear Scene
            dropCarried();
            currentInteractables.forEach(o => scene.remove(o));
            currentInteractables = [];
            collisionObjects = [groundPlane];

            currentWorldId = id;
            
            // Load New
            const worldObj = worlds.find(w => w.id === id);
            worldObj.data.forEach(d => {
                let g; const s = CONFIG.blockSize;
                if(d.type === 'plank') g = d.r ? new THREE.BoxGeometry(s*2, s, s) : new THREE.BoxGeometry(s, s, s*2);
                else g = new THREE.BoxGeometry(s, s, s);
                
                const b = new THREE.Mesh(g, materials[d.type]);
                b.position.set(d.x, d.y, d.z);
                b.castShadow = true; b.receiveShadow = true;
                b.userData = { type: d.type, r: d.r };
                if(d.type==='light') b.add(new THREE.PointLight(0xffaa00, 500, 300));
                
                scene.add(b);
                currentInteractables.push(b);
                collisionObjects.push(b);
            });

            renderTabs();
        }

        function renderTabs() {
            const container = document.getElementById('tab-container');
            const addBtn = document.getElementById('add-tab-btn');
            container.innerHTML = ''; // clear
            
            worlds.forEach(w => {
                const btn = document.createElement('div');
                btn.className = `world-tab ${w.id === currentWorldId ? 'active' : ''}`;
                btn.onclick = () => switchWorld(w.id);
                btn.innerHTML = `World ${w.id} <span class="del-tab" onclick="deleteWorld(${w.id}, event)">√ó</span>`;
                container.appendChild(btn);
            });
            container.appendChild(addBtn);
        }

        function downloadWorld() {
            saveCurrentWorldState();
            const worldObj = worlds.find(w => w.id === currentWorldId);
            const blob = new Blob([JSON.stringify(worldObj.data)], {type: 'application/json'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `voxel_world_${worldObj.id}.json`;
            a.click();
        }

        function handleFileLoad(e) {
            const f = e.target.files[0];
            if(!f) return;
            const r = new FileReader();
            r.onload = (evt) => {
                try {
                    const data = JSON.parse(evt.target.result);
                    dropCarried();
                    currentInteractables.forEach(o => scene.remove(o));
                    currentInteractables = [];
                    collisionObjects = [groundPlane];
                    // Load straight into current world
                    data.forEach(d => {
                        let g; const s = CONFIG.blockSize;
                        if(d.type === 'plank') g = d.r ? new THREE.BoxGeometry(s*2, s, s) : new THREE.BoxGeometry(s, s, s*2);
                        else g = new THREE.BoxGeometry(s, s, s);
                        const b = new THREE.Mesh(g, materials[d.type]);
                        b.position.set(d.x, d.y, d.z);
                        b.castShadow = true; b.receiveShadow = true;
                        b.userData = {type:d.type, r:d.r};
                        if(d.type==='light') b.add(new THREE.PointLight(0xffaa00, 500, 300));
                        scene.add(b);
                        currentInteractables.push(b);
                        collisionObjects.push(b);
                    });
                } catch(err) { alert("Invalid file"); }
            };
            r.readAsText(f);
            e.target.value = '';
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>