<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Voxel Builder - Big Platform</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap');

        :root {
            --bg-color: #333;
            --sky-color: #a8d9ef;
            --ui-bg: rgba(255, 255, 255, 0.2);
            --slot-bg: #444;
            --slot-border: #555;
            --text-color: #fff;
            --btn-bg: #fff;
            --btn-text: #333;
        }

        body.dark-mode {
            --bg-color: #1a1a2e;
            --sky-color: #1a1a2e;
            --ui-bg: rgba(0, 0, 0, 0.4);
            --slot-bg: #2a2a2a;
            --slot-border: #444;
            --text-color: #eee;
            --btn-bg: #444;
            --btn-text: #fff;
        }

        body { margin: 0; overflow: hidden; font-family: 'Fredoka', sans-serif; user-select: none; background: var(--sky-color); transition: background 0.3s; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
        }

        /* Top Control Bar */
        #top-bar {
            position: absolute; top: 20px; left: 20px;
            display: flex; gap: 10px; pointer-events: auto; align-items: center;
        }

        /* World Tabs */
        #tab-container {
            display: flex; gap: 8px; margin-left: 20px;
            background: rgba(0,0,0,0.2); padding: 5px; border-radius: 30px;
            backdrop-filter: blur(4px);
        }

        .world-tab {
            background: rgba(255,255,255,0.2); color: white;
            border: none; padding: 8px 15px; border-radius: 20px;
            cursor: pointer; font-family: inherit; font-weight: 600; font-size: 12px;
            transition: all 0.2s; display: flex; align-items: center; gap: 5px;
        }
        .world-tab.active { background: #4CAF50; box-shadow: 0 4px 0 #2E7D32; transform: translateY(-2px); }
        .world-tab:hover:not(.active) { background: rgba(255,255,255,0.4); }

        .del-tab {
            width: 16px; height: 16px; background: rgba(0,0,0,0.2); border-radius: 50%;
            display: flex; align-items: center; justify-content: center; font-size: 10px;
        }
        .del-tab:hover { background: #FF5252; }

        /* Buttons */
        button.btn {
            background: var(--btn-bg); color: var(--btn-text); border: none;
            padding: 10px 20px; border-radius: 30px; cursor: pointer;
            font-family: inherit; font-weight: 600; font-size: 14px;
            box-shadow: 0 4px 0 #999, 0 5px 10px rgba(0,0,0,0.2);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        button.btn:active { transform: translateY(4px); box-shadow: 0 0 0 #999, inset 0 2px 5px rgba(0,0,0,0.1); }
        button.btn.primary { background: #4CAF50; color: white; box-shadow: 0 4px 0 #2E7D32; }

        /* Instructions */
        #instructions {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0,0,0,0.5); padding: 15px; border-radius: 12px;
            color: white; font-size: 13px; line-height: 1.6; backdrop-filter: blur(4px);
        }
        #instructions b { color: #87CEEB; }

        /* Trash Bin */
        #trash {
            position: absolute; bottom: 30px; right: 30px;
            width: 80px; height: 80px;
            background: rgba(255, 69, 58, 0.2);
            border: 3px dashed #ff453a; border-radius: 20px;
            display: flex; align-items: center; justify-content: center;
            color: #ff453a; font-weight: bold; font-size: 12px; text-align: center;
            pointer-events: auto; cursor: pointer; transition: all 0.2s;
        }
        #trash:hover { background: rgba(255, 69, 58, 0.8); color: white; border-style: solid; transform: scale(1.1); }

        /* Hotbar */
        #hotbar {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: var(--ui-bg); backdrop-filter: blur(5px);
            padding: 10px; border-radius: 16px;
            display: flex; gap: 12px; border: 2px solid rgba(255,255,255,0.5);
            pointer-events: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .slot-container { display: flex; flex-direction: column; align-items: center; cursor: pointer; }
        
        .slot {
            width: 60px; height: 60px; border-radius: 12px;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            background-color: var(--slot-bg);
            border: 3px solid var(--slot-border);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            background-size: 70%; background-repeat: no-repeat; background-position: center;
            image-rendering: pixelated;
        }

        .slot-container:hover .slot { transform: scale(1.15) translateY(-5px); border-color: #fff; z-index: 10; }
        .slot-container:active .slot { transform: scale(0.95); }

        .slot-label {
            margin-top: 5px; color: white; font-size: 12px; font-weight: 600;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8); opacity: 0; transition: opacity 0.2s;
            position: absolute; bottom: -20px; width: 100%; text-align: center; pointer-events: none;
        }
        .slot-container:hover .slot-label { opacity: 1; }

        /* Carrying Cursor */
        #carrying-cursor {
            position: fixed; pointer-events: none; z-index: 100;
            display: none; font-size: 24px; filter: drop-shadow(0 0 5px rgba(0,0,0,0.5));
        }

        #fileInput { display: none; }
    </style>
</head>
<body class="light-mode">

    <div id="ui-layer">
        <div id="top-bar">
            <button class="btn" onclick="downloadWorld()">üíæ Save</button>
            <button class="btn" onclick="triggerLoad()">üìÇ Load</button>
            <button class="btn primary" onclick="toggleTheme()">üåó Theme</button>
            
            <div id="tab-container">
                <button class="world-tab" onclick="createNewWorld()" style="padding: 5px 10px;">+</button>
            </div>
        </div>

        <div id="instructions">
            üñ±Ô∏è <b>Click Block</b>: Pick Up<br>
            üñ±Ô∏è <b>Click Empty</b>: Place<br>
            üñ±Ô∏è <b>Right Drag</b>: Rotate Cam<br>
            üóëÔ∏è <b>Click Red Bin</b>: Delete<br>
            ‚å®Ô∏è <b>ESC Key</b>: Cancel
        </div>

        <div id="trash" onclick="dropCarried()">CLICK TO<br>DELETE</div>

        <div id="hotbar">
            </div>

        <div id="carrying-cursor">üì¶</div>
    </div>

    <input type="file" id="fileInput" accept=".json">

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        const CONFIG = {
            blockSize: 50,
            islandSize: 60, // Significantly Larger Platform
            waterLevel: -25,
            skyColorLight: 0xa8d9ef,
            skyColorDark: 0x1a1a2e,
            maxWorlds: 10
        };

        // --- Block Types (Cubes Only) ---
        const BLOCK_TYPES = [
            { id: 'grass', label: 'Grass', color: '#58a04c', noise: true },
            { id: 'stone', label: 'Stone', color: '#7d7d7d', noise: true },
            { id: 'wood', label: 'Log', color: '#8b5a2b', noise: true },
            { id: 'brick', label: 'Brick', color: '#a04c4c', noise: true },
            { id: 'plank_cube', label: 'Wood', color: '#d2a679', noise: false }, // Renamed from plank, made cube
            { id: 'glass', label: 'Glass', color: '#aed9e0', noise: false, opacity: 0.5 },
            { id: 'waterBlock', label: 'Water', color: '#4fa4b8', noise: false, opacity: 0.7 },
            { id: 'light', label: 'Lamp', color: '#fff3bb', noise: false, emissive: true }
        ];

        let camera, scene, renderer, controls;
        let groundPlane, waterMesh;
        let raycaster, pointer;
        
        let worlds = [];
        let currentWorldId = null;
        let worldCounter = 1;

        let interactableObjects = []; 
        let obstacleObjects = []; 
        
        let carriedBlock = null; 
        let placementGhost = null; 
        const materials = {};
        let isDarkMode = false;

        init();
        animate();

        // Global functions
        window.spawnBlock = spawnBlock;
        window.downloadWorld = downloadWorld;
        window.triggerLoad = () => document.getElementById('fileInput').click();
        window.toggleTheme = toggleTheme;
        window.createNewWorld = createNewWorld;
        window.switchWorld = switchWorld;
        window.deleteWorld = deleteWorld;
        window.dropCarried = dropCarried;

        document.getElementById('fileInput').addEventListener('change', handleFileLoad, false);

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.skyColorLight);
            scene.fog = new THREE.Fog(CONFIG.skyColorLight, 500, 3500);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 8000);
            camera.position.set(1600, 1400, 1600); // Zoomed out for bigger island

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            setupLighting();
            generateMaterialsAndUI();
            createEnvironment();

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.1;
            controls.minDistance = 200;
            controls.maxDistance = 4000;
            controls.mouseButtons = { LEFT: null, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.ROTATE };

            raycaster = new THREE.Raycaster();
            pointer = new THREE.Vector2();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('pointerdown', onPointerDown);
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('keydown', (e) => { if(e.key==='Escape') dropCarried(); });

            createNewWorld();
        }

        function generateMaterialsAndUI() {
            const hotbar = document.getElementById('hotbar');
            
            BLOCK_TYPES.forEach(block => {
                // Texture Gen
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = block.color; ctx.fillRect(0,0,64,64);
                
                if(block.noise) {
                    for(let i=0; i<300; i++) {
                        ctx.fillStyle = Math.random()>0.5 ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
                        ctx.fillRect(Math.random()*64, Math.random()*64,4,4);
                    }
                    ctx.strokeStyle = "rgba(0,0,0,0.15)"; ctx.lineWidth = 4; ctx.strokeRect(0,0,64,64);
                } else if(block.id === 'glass') {
                    ctx.strokeStyle = "rgba(255,255,255,0.5)"; ctx.lineWidth = 4; ctx.strokeRect(0,0,64,64);
                    ctx.beginPath(); ctx.moveTo(0,64); ctx.lineTo(20,44); ctx.stroke();
                }

                const tex = new THREE.CanvasTexture(canvas);
                tex.magFilter = THREE.NearestFilter; tex.colorSpace = THREE.SRGBColorSpace;
                
                // Material Creation
                const matParams = { map: tex };
                if(block.opacity) { matParams.transparent = true; matParams.opacity = block.opacity; }
                if(block.emissive) { matParams.emissive = block.color; matParams.emissiveIntensity = 0.5; }

                if(block.id === 'grass') {
                     const dirtC = document.createElement('canvas'); dirtC.width=64; dirtC.height=64;
                     const dCtx = dirtC.getContext('2d'); dCtx.fillStyle = '#5d4037'; dCtx.fillRect(0,0,64,64);
                     for(let i=0; i<200; i++) { dCtx.fillStyle='rgba(0,0,0,0.1)'; dCtx.fillRect(Math.random()*64, Math.random()*64,4,4); }
                     dCtx.strokeStyle = "rgba(0,0,0,0.1)"; dCtx.lineWidth=4; dCtx.strokeRect(0,0,64,64);
                     const dirtTex = new THREE.CanvasTexture(dirtC); dirtTex.magFilter = THREE.NearestFilter; dirtTex.colorSpace = THREE.SRGBColorSpace;
                     materials[block.id] = [
                         new THREE.MeshLambertMaterial({map: dirtTex}), new THREE.MeshLambertMaterial({map: dirtTex}),
                         new THREE.MeshLambertMaterial(matParams), new THREE.MeshLambertMaterial({map: dirtTex}),
                         new THREE.MeshLambertMaterial({map: dirtTex}), new THREE.MeshLambertMaterial({map: dirtTex})
                     ];
                } else {
                    materials[block.id] = new THREE.MeshLambertMaterial(matParams);
                }

                // UI Icon
                const container = document.createElement('div');
                container.className = 'slot-container';
                container.onclick = () => spawnBlock(block.id);
                
                const slot = document.createElement('div');
                slot.className = 'slot';
                slot.style.backgroundImage = `url(${canvas.toDataURL()})`;
                
                const label = document.createElement('span');
                label.className = 'slot-label';
                label.innerText = block.label;

                container.appendChild(slot);
                container.appendChild(label);
                hotbar.appendChild(container);
            });

            // Water material
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const ctx = c.getContext('2d'); ctx.fillStyle='#29b6f6'; ctx.fillRect(0,0,64,64);
            for(let i=0;i<50;i++){ ctx.fillStyle='rgba(255,255,255,0.2)'; ctx.fillRect(Math.random()*60, Math.random()*60, 8,2); }
            const t = new THREE.CanvasTexture(c); t.magFilter=THREE.NearestFilter; 
            materials['water'] = new THREE.MeshLambertMaterial({ color: 0x22aaff, transparent: true, opacity: 0.8, map: t });
        }

        function setupLighting() {
            const ambient = new THREE.AmbientLight(0xffffff, 0.65);
            scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xfff5e1, 1.2);
            sun.name = 'sun';
            sun.position.set(500, 1000, 500);
            sun.castShadow = true;
            sun.shadow.mapSize.set(2048, 2048);
            scene.add(sun);
        }

        function createEnvironment() {
            // Big Water Plane
            const waterGeo = new THREE.PlaneGeometry(8000, 8000);
            waterGeo.rotateX(-Math.PI / 2);
            const waterTex = materials['water'].map;
            waterTex.wrapS = THREE.RepeatWrapping; waterTex.wrapT = THREE.RepeatWrapping;
            waterTex.repeat.set(40, 40);
            waterMesh = new THREE.Mesh(waterGeo, materials['water']);
            waterMesh.position.y = -20;
            scene.add(waterMesh);

            // Large Island Base
            const size = CONFIG.blockSize * CONFIG.islandSize;
            const islandGeo = new THREE.BoxGeometry(size, CONFIG.blockSize, size);
            groundPlane = new THREE.Mesh(islandGeo, materials['grass']);
            groundPlane.position.y = -CONFIG.blockSize / 2;
            groundPlane.receiveShadow = true;
            scene.add(groundPlane);
            obstacleObjects.push(groundPlane);

            generateNature(size);
        }

        function generateNature(islandWidth) {
            const count = 50; // More trees for bigger island
            const minDist = islandWidth / 2 + 100;
            const maxDist = islandWidth / 2 + 1000;
            const trunkGeo = new THREE.BoxGeometry(30, 60, 30);
            const leaveGeo = new THREE.BoxGeometry(70, 70, 70);

            for(let i=0; i<count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = minDist + Math.random() * (maxDist - minDist);
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;

                const trunk = new THREE.Mesh(trunkGeo, materials['wood']);
                trunk.position.set(x, 10, z);
                trunk.castShadow = true;
                
                const leaves = new THREE.Mesh(leaveGeo, materials['grass'][2]); 
                leaves.position.set(0, 50, 0);
                leaves.castShadow = true;
                trunk.add(leaves);

                trunk.userData = { bobOffset: Math.random()*100, baseY: 10 };
                trunk.name = "nature_asset";
                scene.add(trunk);
            }
        }

        // --- Interaction ---
        function spawnBlock(type) {
            if(carriedBlock) dropCarried();
            const size = CONFIG.blockSize;
            // Everything is a cube now
            const geo = new THREE.BoxGeometry(size, size, size);
            
            carriedBlock = new THREE.Mesh(geo, materials[type]);
            carriedBlock.castShadow = true;
            carriedBlock.receiveShadow = true;
            carriedBlock.userData = { type: type };
            
            if(type === 'light') carriedBlock.add(new THREE.PointLight(0xffaa00, 600, 400));

            scene.add(carriedBlock);
            
            placementGhost = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color:0x00ff00, wireframe:true, opacity:0.5, transparent:true}));
            scene.add(placementGhost);
            
            updateCursor(true);
        }

        function onPointerDown(e) {
            if(e.button !== 0 || e.target.closest('#ui-layer button') || e.target.closest('.slot-container') || e.target.closest('#trash')) return;
            
            updatePointer(e);
            raycaster.setFromCamera(pointer, camera);

            if(carriedBlock) {
                // Place
                const intersects = raycaster.intersectObjects(obstacleObjects, false);
                if(intersects.length > 0) {
                    carriedBlock.position.copy(placementGhost.position);
                    interactableObjects.push(carriedBlock);
                    obstacleObjects.push(carriedBlock);
                    carriedBlock = null;
                    scene.remove(placementGhost);
                    placementGhost = null;
                    updateCursor(false);
                }
            } else {
                // Pick Up
                const intersects = raycaster.intersectObjects(interactableObjects, false);
                if(intersects.length > 0) {
                    const target = intersects[0].object;
                    carriedBlock = target;
                    interactableObjects = interactableObjects.filter(o => o !== target);
                    obstacleObjects = obstacleObjects.filter(o => o !== target);
                    
                    placementGhost = new THREE.Mesh(target.geometry, new THREE.MeshBasicMaterial({color:0x00ff00, wireframe:true}));
                    scene.add(placementGhost);
                    updateCursor(true);
                }
            }
        }

        function onPointerMove(e) {
            if(!carriedBlock) return;
            updatePointer(e);
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(obstacleObjects, false);
            
            if(intersects.length > 0) {
                const hit = intersects[0];
                const size = CONFIG.blockSize;
                const pos = new THREE.Vector3().copy(hit.point).add(hit.face.normal.multiplyScalar(size/2));
                pos.divideScalar(size).floor().multiplyScalar(size).addScalar(size/2);
                
                placementGhost.position.copy(pos);
                carriedBlock.position.set(0, 8000, 0); 
            }
        }

        function dropCarried() {
            if(!carriedBlock) return;
            scene.remove(carriedBlock);
            if(placementGhost) scene.remove(placementGhost);
            carriedBlock = null; placementGhost = null;
            updateCursor(false);
        }
        
        function updatePointer(e) { pointer.set((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1); }
        function updateCursor(active) {
            const c = document.getElementById('carrying-cursor');
            c.style.display = active ? 'block' : 'none';
            document.body.style.cursor = active ? 'none' : 'default';
            if(active) {
                const track = (e) => { c.style.left = e.clientX+15+'px'; c.style.top = e.clientY+15+'px'; };
                document.addEventListener('pointermove', track, {once: !active});
            } else {
                document.body.style.cursor = 'default';
            }
        }

        // --- System Logic ---
        function toggleTheme() {
            isDarkMode = !isDarkMode;
            document.body.className = isDarkMode ? 'dark-mode' : 'light-mode';
            const col = isDarkMode ? CONFIG.skyColorDark : CONFIG.skyColorLight;
            scene.background.setHex(col);
            scene.fog.color.setHex(col);
        }

        function createNewWorld() {
            if(worlds.length >= CONFIG.maxWorlds) return alert("Max 10 worlds!");
            const newWorld = { id: worldCounter++, data: [] };
            worlds.push(newWorld);
            renderTabs();
            switchWorld(newWorld.id);
        }

        function deleteWorld(id, e) {
            e.stopPropagation();
            if(worlds.length <= 1) return;
            if(!confirm("Delete world?")) return;
            const idx = worlds.findIndex(w => w.id === id);
            worlds.splice(idx, 1);
            if(currentWorldId === id) {
                clearScene();
                switchWorld(worlds[0].id);
            } else {
                renderTabs();
            }
        }

        function switchWorld(id) {
            if(currentWorldId === id) return;
            saveState();
            clearScene();
            currentWorldId = id;
            loadState(worlds.find(w => w.id === id).data);
            renderTabs();
        }

        function saveState() {
            if(!currentWorldId) return;
            const w = worlds.find(w => w.id === currentWorldId);
            w.data = interactableObjects.map(b => ({
                type: b.userData.type, x: b.position.x, y: b.position.y, z: b.position.z
            }));
        }

        function loadState(data) {
            data.forEach(d => {
                const s = CONFIG.blockSize;
                const g = new THREE.BoxGeometry(s, s, s);
                const b = new THREE.Mesh(g, materials[d.type]);
                b.position.set(d.x, d.y, d.z);
                b.castShadow = true; b.receiveShadow = true;
                b.userData = {type:d.type};
                if(d.type==='light') b.add(new THREE.PointLight(0xffaa00, 600, 400));
                scene.add(b);
                interactableObjects.push(b);
                obstacleObjects.push(b);
            });
        }

        function clearScene() {
            dropCarried();
            interactableObjects.forEach(o => scene.remove(o));
            interactableObjects = [];
            obstacleObjects = [groundPlane];
        }

        function renderTabs() {
            const container = document.getElementById('tab-container');
            const addBtn = container.lastElementChild;
            container.innerHTML = '';
            worlds.forEach(w => {
                const btn = document.createElement('div');
                btn.className = `world-tab ${w.id === currentWorldId ? 'active' : ''}`;
                btn.onclick = () => switchWorld(w.id);
                btn.innerHTML = `World ${w.id} <span class="del-tab" onclick="deleteWorld(${w.id}, event)">√ó</span>`;
                container.appendChild(btn);
            });
            container.appendChild(addBtn);
        }

        function downloadWorld() {
            saveState();
            const w = worlds.find(w => w.id === currentWorldId);
            const blob = new Blob([JSON.stringify(w.data)], {type: 'application/json'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `voxel_world_${w.id}.json`;
            a.click();
        }

        function handleFileLoad(e) {
            const f = e.target.files[0];
            if(!f) return;
            const r = new FileReader();
            r.onload = (evt) => {
                try {
                    const data = JSON.parse(evt.target.result);
                    clearScene();
                    loadState(data);
                } catch(err) { alert("Invalid file"); }
            };
            r.readAsText(f);
            e.target.value = '';
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate(time) {
            requestAnimationFrame(animate);
            controls.update();
            if(waterMesh) {
                waterMesh.material.map.offset.y += 0.001;
                waterMesh.material.map.offset.x += 0.0005;
            }
            scene.traverse((obj) => {
                if(obj.name === 'nature_asset') {
                    obj.position.y = obj.userData.baseY + Math.sin(time * 0.002 + obj.userData.bobOffset) * 2;
                }
            });
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>